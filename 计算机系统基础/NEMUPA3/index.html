<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="aa10n.github.io.xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CRoboto+Condensed:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"aa10n.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.7.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":20},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="高速缓存及MMU  PA3主要实现高速缓存、分段、分页机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统基础综合实践 NEMU PA3">
<meta property="og:url" content="https://aa10n.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA3/index.html">
<meta property="og:site_name" content="aa10n&#39;s blog">
<meta property="og:description" content="高速缓存及MMU  PA3主要实现高速缓存、分段、分页机制。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/png;base64,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">
<meta property="og:image" content="https://i.loli.net/2021/09/28/WxMc1XUerw4VCiO.png">
<meta property="og:image" content="https://i.loli.net/2021/09/28/3fp6vkXAUnScxWs.png">
<meta property="og:image" content="https://www.cs.cmu.edu/~410/doc/segments/segsel.gif">
<meta property="og:image" content="https://lh3.googleusercontent.com/proxy/1jwqePVVHC3nSWQnPTTbegSX4eYiZ8n60TH-Hy4vwuqzz5aXl4YlJh4XWEilQn_PJGab2-CTU8GV0H5oNFWObUXmZif6LPSyrfDTsxMATYBTYqGzkg">
<meta property="og:image" content="https://www.cs.umd.edu/~meesh/cmsc411/website/saltz/cs412/lect3-p2.gif">
<meta property="og:image" content="https://www.cs.uaf.edu/2007/fall/cs301/lecture/11_30_cache.png">
<meta property="og:image" content="https://i.stack.imgur.com/PolxM.png">
<meta property="article:published_time" content="2021-09-27T16:41:01.000Z">
<meta property="article:modified_time" content="2021-10-01T14:44:40.511Z">
<meta property="article:author" content="aa10n">
<meta property="article:tag" content="NEMU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/png;base64,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">


<link rel="canonical" href="https://aa10n.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://aa10n.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA3/","path":"计算机系统基础/NEMUPA3/","title":"计算机系统基础综合实践 NEMU PA3"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机系统基础综合实践 NEMU PA3 | aa10n's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-KERBMHHC6M"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-KERBMHHC6M","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">aa10n's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E5%AE%9E%E9%AA%8C"><span class="nav-text">开始实验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-text">高速缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E5%81%9A%E4%BB%BB%E5%8A%A1-1%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%BA%A7-Cache"><span class="nav-text">必做任务 1：实现一级 Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E5%81%9A%E4%BB%BB%E5%8A%A1-1%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7-Cache"><span class="nav-text">选做任务 1：实现二级 Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">分段机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E5%81%9A%E4%BB%BB%E5%8A%A12%EF%BC%9A%E5%9C%A8-NEMU-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">必做任务2：在 NEMU 中实现分段机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">分页机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E5%81%9A%E4%BB%BB%E5%8A%A1-3%EF%BC%9A%E5%9C%A8-NEMU-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">必做任务 3：在 NEMU 中实现分页机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E5%81%9A%E4%BB%BB%E5%8A%A1-2%EF%BC%9A%E7%AE%80%E6%98%93%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-text">选做任务 2：简易调试器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E5%81%9A%E4%BB%BB%E5%8A%A1-3%EF%BC%9A%E4%B8%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA-video-memory-%E6%98%A0%E5%B0%84"><span class="nav-text">选做任务 3：为用户进程创建 video memory 映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%85%E5%81%9A%E4%BB%BB%E5%8A%A1-4%EF%BC%9A%E5%AE%9E%E7%8E%B0-TLB"><span class="nav-text">必做任务 4：实现 TLB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%87%AA%E6%9F%A5%E8%A1%A8"><span class="nav-text">任务自查表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="nav-text">思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-text">后记</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aa10n"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">aa10n</p>
  <div class="site-description" itemprop="description">一个菜鸡的blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FhMTBu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aa10n"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmppbmRlMDUwMUBnbWFpbC5jb20=" title="E-Mail → mailto:jinde0501@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9qaW5kZV8wNTAxLw==" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;jinde_0501&#x2F;"><i class="fab fa-instagram fa-fw"></i>Instagram</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aa10n.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="aa10n">
      <meta itemprop="description" content="一个菜鸡的blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aa10n's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机系统基础综合实践 NEMU PA3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：星期二, 9月 28日 2021年 00:41:01" itemprop="dateCreated datePublished" datetime="2021-09-28T00:41:01+08:00">星期二, 9月 28日 2021年</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机系统基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center><font size=6>高速缓存及MMU</font></center>

<p>PA3主要实现高速缓存、分段、分页机制。</p>
<span id="more"></span>

<table><tr><td bgcolor=blue><center><b><a href=https://pan.baidu.com/s/1ghLreFGtrCEnDIzEJsTUUA target="_blank">实验指导书</a>，提取码：9h8k</b></center></td></tr></table>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此次PA是为了理解高速缓存的机制以及从逻辑地址到线性地址（分段）、线性地址到物理地址（分页）之间的关系。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>阶段 1: 实现 cache（必做）和二级 cache（选做）</li>
<li>阶段 2: 实现 IA-32 分段机制 </li>
<li>阶段 3：实现 IA-32 分页机制</li>
</ul>
<h2 id="开始实验"><a href="#开始实验" class="headerlink" title="开始实验"></a><center><font size=6>开始实验</font></center></h2><hr>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>在计算机系统中，其实内存的速度相对于cpu来说是非常慢的，这时候就需要有一个cache来弥补这种差异上的速度，而内存又可以分成两种，分别为SRAM和DRAM。</p>
<center><b>DRAM和SRAM的电路图</b></center>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUkAAACZCAMAAACVHTgBAAAAh1BMVEX////+/v6RkZHt7e2xsbHz8/OpqakAAADNzc3U1NT7+/vv7++tra3///339/eQkJCenp7n5+fd3d3CwsK5ubnX19dVVVXHx8d+fn6Xl5dgYGC8vLx3d3egoKBaWlpvb2+GhoZDQ0NNTU1nZ2c3NzdHR0cqKio0NDQmJiYeHh4NDQ0WFhYvLy9Y5YdCAAAU80lEQVR4nO1diXqqvBbdkTlYMIBMgkza4Zy+//PdBARBAcPQ9r89rvZDzbiz2Jk2SQB44oknnnjiiSee+LeBUPfnnQOqrtTjqyXpfEV32aHyDyZIglCZCkKXApRfFpXjXqqOeJ1fpaCoFQNdBEEjqayBtiQXGVDb8XIzJwhS8oY9GlxS6yRhUTHGbgP10VqyVvfwpgCopnO+CI+httJvBGjXkJrXCUpFdHoJacpxcEkXljJ5ZavHz2z9qInEV7ernn4plWb7TqGGzG7duHUbBQLbopeDD/BqgB3tMDhRfNd8TUGHrXtsWt8PImDXAm/bclMdenHU8uNSii+gdNP9GatgnQFEu5Wdw+qoKTheS5BRSSiTAEYG1hFIRgLPykmqLhR+w+lnueC9yZAeACQJkCFhJIk76hE4OkFYMqgchv6oBDMlbFdkMYD41YNMqAVB2IjZvQwtImCsG1B6jAvCmESQeqbH0gOQ4yr5hXJy+UlHmnEGHzT/40kUXk/eMfyUqcfu4MjqKfy0QHsLky/Qyk23dksZ5GoKZwype3Kkj7cDzZzeXwhJfHDO4TsB8ZzvxqksdRJImNGvCagHO4LD9+gklSpSXSp+BnsX9PM+B9GEHbuTlMlYjYCqxdkhmbY+lZtuktilQrxSLtUQhEx4BdOBomEyhd0WFIv8EUblqHQSXFapijDXcRgepe+p3axWJbCLYvBoO32kpQhEcGLqXjK5AVmED1kWrS/WSYogkiEMbPAiMFza6Pgq7MraTZkUZYhFULby1hi9pRcmqwuuv3B3WL0BeWs3CIoNe8UC40OTQ+KC9Sm4jMmAMumZrACRid90PmGm4JZJjwohKhiEExVEOoMTCsqBBjmSnSPGTCffbZIbD3VyNgaGS7y1G+GtULlYaYAlkfbcvqhRcVXL0ogH2p5WdF/74h6nlIV2EYKImCA7bFBBHN9hVcGRNCoKqHswzJSMDw8XMTmQNBeT9SziLpHmZ+26aFA2KMVNkp0s6klrI8D90P0ey3Sy33mMyWDEz0udLxyOt5Pul0KPgwVseGR+XFobUwffu/YzqYsMoTiIQFGUwhn272CrTeyH6CSkiez0SnF4V5Q/Mmf+90iD2VEHy96Sc9vcKIQFCimVhAFILk1NsYa874JPZlK/xu2TQtqy/IflewBdVPXHoQZgZDTrP3dl78hpcOlrCZOm9jqJm0lMtoP3SqEzJr1JibaxqJ3c0KxPPc7tH+25BJvJDqcmvCpvNj8/U5vU9pDN7I3tK4rf01hx5rWISfKhnOzbfNCdvaeN0X6dSF9sTWtJ0ZOPsycLJvmed1v/BtA74DFJX2zukXk3g7J830LkAJOiDn2WXUHjgRX9OcV7joD9heznZS6TJiy0MnNjgEmhl0lT5YDGWjpF5Ai57WWyv72Zr5NfbStvSTHAZH9gDsSMyUEbdyc5/kzmMckr8hoYZHIgMAcsSmTW31/xJPdk8grPTS2eKvVk8gG6U/XxvBe6LvNbF+szeTHGPHWyxLLaPSHvha7L/NbFk8m18GRyLTyZXAuTmGRmBLRwIttadjRlNvPLmHRMcws2nrZKqItqEZQDRrQx1S+fd/9nmaTYwY5NX+YbBcqIJujiUCr/BpMI7yBGQITZVgGqzESnuerboYWE/waTwJgkbpSE10fvHA88W2sIwc790DQZk8MScbsu81sX05ncvmu0xUzaruNMdogmGQEUuE8mKZOyz6IU9tViix/p5NVCvDdZ+yiFTyYZkymLkTiNwTYd7J5qXC3Ems8WGT2ZrGr3X+qphhyB25nU2B8NGsN/Msl6HDVP/dziCNzOpEHsmlEiP5ksR0HYa6/zn8Qk7X0EW4Nn392MzNsd8iSdRJd5YjkyfxT4oesyv2pZ51o7IiYxeWCzxcPtI5pptRvKhbflbLF/FeOXM3lIEt+77DtCMDRBmIwZFozbfKczebVg/ASTmx3ZK9fldGs9wp1qVeu5gTOYrPRg80NMHgAyi5zOJ+nw9rYD9f0zHkmBFxOZ7Nv+N5NJ+Ckmg09XSUAj2N1HO0MFP8DqSAq8mG7pvWuhJzNZPzX7IUtvsGWTMvVs5hoKTnTGVl4WYwWb+Qwmx5y/nEk2YWXTXZyppiookKqGwrkkbAz/IJOH0sJM/HTrkZT24kIazV8r2snpX2PyBj/Vd/fg/4bJ+2FHvat+jQHlP8xks3NnneWV/xCT+i1l9JcmlVQaPEvrHuDfYVKPery31VOUdNEOoianf4JJBNt329pFxPQ34MiRDJrvE8qkFkWC/ukjK/UJDvz+J8c8WInJ8bbm55mk0lmhYZ+s7VY4W6YvvBpn25MhsXLN20KoGplq58JfT/9hJh+02v8JJkkCtgm6Gb3RATmEwiGLLEiI/VZ+7At2CMp5waBogMn+/c8DTJJHuf8Ik0iiwCkuPxiTBdgbSERISiaJg+2M6uQW1Hf6QXJDz0m2YJPtHZMGzdiQrfKDT+TglDss+CCwiZvvxlhy7bJzZT3mJ21liri8sCqGzztvA6IbnQ+UyUKIj0dau4nsuiLIJ7Q7Z6KUjeTyCHdMek3+ss0lssC2Opil2APYho3vNtGv+d0mh+Vr3red6bJ5zChWMpr31+7hwPcQGZPyaLzW1men1QJPYWA5k6iezaDaynq5QNt+PkGkeykWMikxJslIKqgdr73T52uZPPibBvWtRFDPa6D+bx8at2i2cyuFcQya7As+kXev7t2WzcF4bSZvd+lv06bo6a2SDzOJILD7piht7R86lWC1bXjsCYAtdZxw6+npXf4bu8+OJ0o9jt14rcCtUUF0Y6qWr+XCt0wGZMCujUCjdSK4a6e3hXDdz5L3NuMTtis/AM3Duu0tdvI1/6ib/1ZuidzqjSbNccSgSS5SlDexnf4R1+du0KrRzVs80sAD5S6oWJ/4fsjQ2hnUO7TA6ZpMRqyR6+SD6/wR3EpHS6N8VI5G2iJnCpPXNAnLOmjnYUDDJHRzNpjeKU5/6iH1+ttbvDqxAcL6903OAarup3IrwMXzLpuwFbi1z3/mvLs82KDbgCC43sYutJEBwmGY5BlizQJ7LnRXmhE4NPD2EnM6kzcWLVTexYdNbA12PMbQwxZ/Z81SrvWYZMVJd3tOKWgwP2hE7nbHD7CBu26SjTuOMu+hXKx/lgdPTtnM7IRX1EmEJqR2CXxpe1rxnIeKVRQb/ZYGVI4N+AhAZR0YGO2V5wrMGgmuq5Mmb2kqJpvjZ83rqDe8DgN7ESS0Zro3+QyvwejNe1TOsfNSx7Aik7DGHOexTibl8Ue8yfVhvO7MZeQ/x+TDdpId5/DWo37fO+9eL95gal/OpJF9nLyebJ5M3uARk7Tj7T/Z98nkDVZ+IjY97JPJJ5M3eDJZp/b7mLwv0eV1EPPzf4zfxSRqniN0UdvH0UC8NfDLmCwvPQXq9XgyOeiHYB/s+o/PIjaQp04+Cnv1O7iqfepdLUU0Pbl1+3Emb8PPY3JwxT5/Evd+LlVIlZAwTMD0jzGgXZhrIB8LrMnbvyIExwQfiuxShB9lsu9YzOlMju7H4Uui1093S2OKo+kfQhKgM5F2WCxIhh3VS0kBso/NQI6k23irYCqTq+xsgrH9OFxJDPjlVBSLWEX6ShICqY3MyC8O7KGAl9LaHalghdvmANEfZLIyBN4+4Vl5tx1XEgN+m1QiuRZ68GElMcqIltOm08pg66ipHmLZR5udvL2PtwYmMSmb5gHuHtPPaCcdMHx2XhA/OEdBZuHKYCd+qkVFIYMU+WYEQZIgbQdJDH6SYOcAgKuVEexqLnpJRVeKSXb7eldyCzOYHNuVzJnEsF9VnpDUP9pvupv6crkJmMgk2ym/ApObkZ3ynEn0+qF6KoPYCvJ6ithaVdV+wx2qd6Kug9/FJNQ7bKqv17fyXR3uZ+ArUfnbmOREtbKjWnTyc0zqNytN4oc2c/NmXY4xdg7GoJyz/HoFQuWa161brj36oR6HnRcU3675ergtiNyuI0t+ksmmbeRefMKF6Uzu7l3HU+h9gvOTTNYCV+PZn+xxbtalPBpf3/WP6OfbyUXxBlPjZxKVOomXDhxQfV5Qm+Lryu+bwFXH+8uYhGpkvrQ+MCaF6iTPtiNqD6Gv7hWVv4zJYGN67HTZxTpZzxbbB1PSr32WRQTGL9TJ9bKuLRhXBwT2W5Tte4Im5EHW/zSTPckJHxj2EWDPA2x5HnYogdb+oEPxZHJactsd69GMMIhSQ5Fdd/sJ4IZxaDx1clJyiL3lmy3XLkA6kxPIO8h1yAkU2pPJicntcwC9sCmTuXAGWZ7OpOewt+ppAuJ8nd3XMEmloAJrOoy9B5Mv65b15WHebfhJnIn4GESmcYI4hkyHY7ErjFBwPC4mX4NdboNIDuKs/BeiZvIj2J2ZFNpuOZO8B8d0kqPB9wfadUu2SnscEAhYGFzbk+gnETiYRJAZcEjBsUJ3/E3tvfkvRs3kCYNjUib9bMQ2MkEnpzPZ7ENqXUKh+saxOppGPyXJG4FI3QU/qZOfFymcdEQEzqyRxXfUya1O1qqMmmcEeu0yuip/c4mfaUQswNfYMy+e2cMX6eSebBOING9sa4fJ99LfQlF4QkrBbU6osYfceXDVbh2sM2NS5ttf/EVM0vYoZ0z2v2qlwn7L8dpop9zqYD4OyM7q6V2ft2UzndiS9i3N4mHylGWvHvjq/i/Xq/W+qnZTKVTKpKCoSy12Mu+bK3uLS51SdvSeheVdKwQHk6iV5A/qZFuK4dBcApI/isJ3XExfv8B2W71lLvjW+ZXzpIe6x6mF67Up3WXc2vK2CjbNI+FLFuNpP8q4LIzt825t7U8ulSE9pHtHbjHCMZ7kfYzdhAvGhJiM8r4gjts4Ad7Dh43DYEKkKsRiuhfjVikfM2kA77uu6b0OjxQf7Bqm84Xtl2KVR+hWKeHpzCRkyxVnJMn29/r62fI10W892HjIpOTihI9KmqbxjikQ/Qfu+vMIZe1mUqxwbiDFXwOVEmKQ+feWdsAMlXF0AIcIPpnEJFKxpToSlCt/xnOATb3rXn+dIeOQFIxJUGGvsdNMDs4i1bTTyxd85t4E3wVqf0xoJ6k2uEaWBkcI4yB6NDI36Jyu7D/9cdYnoNbJHM5+7EK0iY+LGsz3y+Z3ee4QY2C1Dg+TR+koGUdJiXfKwzIEcnm3hNOaT2mr+wkugcL6E+yWnEiN4FAdDW7kM1USEMxk8kiZLCTpqL9LgvNwtiidDcYhU8n1+m5UMXkkuLDeBeIsaDGp/J9lxy3PX9+Ae80fj5k807vn6noOhbnxHz6DL5USSMY3Q+dBxeQZnyEn+CikURw+jjQiYKWURs57wsU9UkvuWaL6kElMEP3DmIChavgxP1JulCq52tivGk9SGYBgIAir6qLj5qlcJ6FSybkiJnuiS/qeUI3ZS/w9TpN/ZZJ7qJNMKYm7nkqWOtkamffYYaahbCmXqCQkVqrGmfkuqbl5bFpbnjlOvROAZ4EpAj3HqddamLoUlU6iesNfz+6+SWCRM13mNLX2gjG528LGOwae2wybh5m82C6bo/v6Fpv2RgvSohJ5pqA3MJve8jJ6WzbXYbHtxJUWJFMy6UDgZaJ3uBjwRyy9NJ+ZvZu03OzVRrBeQ9Hgc9HCxMJKvUCEjS0XVn5Zdj/G1nz51XVLvj6RsJ87liyhSnvBIkD/7XjfmBsHtWf+EcWwpk1tVMYlqa6RwrW1QyM3fH4BVtahRbd0IMnFLS1qPR6rHB+xdT1/t/7d6cqvyXVkQ1+lSaOC1p37ZZsGavt1Ajbzvao0+DLEui0GQiuWohnGNaeVNZaQK5k1251YX9G6jQl6pa/nNnbvMqoHIahR+EYp2mKva11GQMrU9GqqW52bbkh66cVm2NUKF6kbxyi9vhUIBMxkrI4txbok6depEG7NinB1pKrAJicSKwhqCoI6ARmrRrXIdAXxKJHVMEmr3venFO7HHs5FlBVUbEWkvaDiAcSfHZsCLoRk7NDrLwBlJd0zG7hUmga0Y/4eXofKWmvULLLRihGGeQTGnyh6TQEs9pzRZifU+XknVd013NVqd2iAJtL5elQaUBSa7RucBfYuB3CCd8okE+WYl0x67Ew92zFQyeS3gg6MLauwqaCXnadqBIQAVvH+4IG+B8GhbFmiXTHpJcwOgT9YkTBs0ojK/UqV5dNlCoAPHtVTx6ZMYnc1AU/ghV6mgVzOitgZuK9SLnpOLkEoJBpoqStZBdNQ2IaiC2Yqh8ZPMHk0LEUORVAr/VMT2B9hG0uKWGxV33C3oUcy7+g4bJ4onJODDsaH6slUC8/YpUPDyIVDkLOkik0aoFDepMZqTCK2GNjw5MwBrbSPMkvvScpT/1UAQVHThDK58wI7ZExmEm0vPzbxxz75dibZezz2BbPmSefyN2UShaQQ9BPouZqqPm0DkSrm20NpBEKenxH8N0hOVEFztQjANlMrKl/1YYW0+pM/caDg9XQSrALiiPgOeCn7SXXSeEW5AHECgS86CtZ8K/LJkTH5psMBPizB1r9fJ0EombRyEI7lb8okyJsCKJPkSJmMQLDs0NrJ5UkJrIaZIqvdSQBhLMo5tk01LXDGynykrQI5SeQgLWfy5eWFfdA24wNk38liCMqD1hXTp/p5ot2JK59oo2gGtJk/bYyynRRdOYRNIhcSVYZv73Fcaa/IuQ2Haq+dV9AO4w9t6pQ4t1ntjkPNC23XdFjtJ1lq5gRTxUCKfaKShradguJInyxukvoxhKZpMvvyjGIw7iiB1Yi1YpK1GQSpqk4gKXuc/Z7ZNy3Km2BZrMMkBgEiYVIOw/YqHU5oqgQEk28eBtEex8NEZd1v1eNIVE7sGiDkmsV+6B5133s6kdj7m0CnhWLLSSmp5QJAgbkTA5ULnwx1Ty+ehrGF5tStisFb13oUJN+ELS/X0B0b7GUqepfWl0JKyw/9+ipcIZTZuvBGvhov6KVxuywufbmGeWk+278m4aVE9zfNgiB6fdGN0rdiG5Xf2AdT3pfLl8oH1f9lqG8DFVTALEvpIii70BbmBekvF4Er8V9ecCUp6kp9cUPoWoSyDGhuMWpCm7uGOreF3cIXdguvC9hQWxFRlcI3z29KlGK+wFX9OlWEcVJ/LQNeinZrFKLyNwm1K9gkNBK8fHO9/HUoNfqnhfgdeKriE0/8avwPkv0UGUB0MLEAAAAASUVORK5CYII="></p>
<p>DRAM中的一个电容用来存储一个bit，而晶体管则充当一个开关。当电容的电量大于50%，就被认为为1，否则为0。由于电容是会漏电的，所以我们还要不断地为电容充电，让DRAM定时刷新，以确保正确性。而CPU的寄存器采用SRAM，是通过一个触发器来存储1个bit，只要不断电，SRAM中存储的数据就不会丢失。可以看到SRAM相比DRAM的电路来得相对更复杂，所以SRAM的成本远远超过DRAM。</p>
<center><b>存储器金字塔层次结构</b></center>

<p><img src="https://i.loli.net/2021/09/28/WxMc1XUerw4VCiO.png" alt="image.png"></p>
<p>为了解决CPU和存储器之间速度的差距，又由于SRAM的成本远远高于DRAM，所以引进了高速缓存的概念。CPU在最上层，速度就是最快的。SRAM在第二层次，其中又可分为L1、L2、L3等高速缓存。第三层对应着主存DRAM，第四层就是我们说的SSD，第五层便是HDD了。这里的金字塔层次结构由上至下的形式也表示了存储器的从小到大。</p>
<br>

<p>高速缓存的原理就是利用时间局部性和空间局部性来达到加速的效果。例如当程序访问了一个内存区间，那么这个内存区间很有可能在不久的将来再次被访问，而这个内存区间周围的邻近区间也很有可能会被访问，前后者分别对应着时间局部性和空间局部性。我们把cache向内存进行读写的基本单位称为block。所以只要CPU访问cache的时候命中所需要的内存区间，就不需要浪费很多时间去访存了。但是这也带来了一系列的问题。例如一个内存区域可以分为几个block？由于cache是有限的，当一个block持续地被写cache、出cache时，如何解决这样的冲突？冲突的时候，需要替换哪个block？这就涉及到了替换算法。当写cache的时候需不需要每次都写回内存里？等等一系列问题，所以cache又可以表示成多种形式。</p>
<ul>
<li><p>直接映射（Direct-Mapped Caches）</p>
</li>
<li><p>组相连映射（ Set Associative Caches）</p>
</li>
<li><p>全相连映射（ Fully Associative Caches）</p>
</li>
</ul>
<blockquote>
<p>这些问题太多太多，懒惰写了，可参考：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNDk1OTU3">多图详解CPU Cache Memory - 云+社区 - 腾讯云 (tencent.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<center><b>高速缓存结构</b></center>

<p><img src="https://i.loli.net/2021/09/28/3fp6vkXAUnScxWs.png" alt="image.png"></p>
<p>这个便是高速缓存的结构。高速缓存被组织成S = 2^s 个set，每个set包含E个line。每个line由一个B = 2^b bit的block、一个valid以及一个tag组成。当高速缓存命中的时候，就是tag和valid被校验成功，这时候就可以取出cache中的存储单位（block），这个存储单位通常以1个字节为单位。当高速缓存不命中的时候，这时候CPU才要去内存中取，之后便会根据时间局部性和空间局部性相关的算法以及策略放进cache里。</p>
<hr>
<h2 id="必做任务-1：实现一级-Cache"><a href="#必做任务-1：实现一级-Cache" class="headerlink" title="必做任务 1：实现一级 Cache"></a>必做任务 1：实现一级 Cache</h2><p>需要实现一个64KB的cache，block为64B，八路组相联映射高速缓存，并且其中的替换算法为随机替换算法，写直通策略。</p>
<center><b>nemu/include/memory/cache.h</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CACHE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CACHE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_BLOCK 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_SIZE 64*1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_l1</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">uint8_t</span> byte[CACHE_BLOCK];</span><br><span class="line">&#125; cache[CACHE_SIZE / CACHE_BLOCK];</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">cache_read</span><span class="params">(<span class="keyword">hwaddr_t</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">hwaddr_t</span> addr,<span class="keyword">size_t</span> len,<span class="keyword">uint32_t</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>定义cache的结构，并且声明了三个函数，分别为初始化cache以及要实现的读写函数。</p>
<center><b>nemu/src/memory/cache.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memory/cache.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;burst.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">dram_read</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_ddr3_read</span><span class="params">(<span class="keyword">hwaddr_t</span>, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_ddr3_write</span><span class="params">(<span class="keyword">hwaddr_t</span>, <span class="keyword">void</span> *, <span class="keyword">uint8_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CACHE_SIZE / CACHE_BLOCK; i++)&#123;</span><br><span class="line">        cache[i].valid = <span class="literal">false</span>;</span><br><span class="line">        cache[i].tag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cache[i].byte, <span class="number">0</span>, CACHE_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">cache_read</span><span class="params">(<span class="keyword">hwaddr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">set</span> = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7f</span>; <span class="comment">//取出地址中set的部分（右移block位并 &amp; 1111111），set = 7 byte (set = 2^s = 128), offset = 6 byte (block = 2^e = 64)</span></span><br><span class="line">    <span class="keyword">bool</span> hit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">set</span> * E; i &lt; (<span class="built_in">set</span> + <span class="number">1</span>) * E; i++) &#123; <span class="comment">//找到相应set所在</span></span><br><span class="line">        <span class="keyword">if</span> (cache[i].tag == (addr &gt;&gt; <span class="number">13</span>) &amp;&amp; cache[i].valid) &#123; <span class="comment">//如果tag和地址相符合并且alid == true</span></span><br><span class="line">            hit = <span class="literal">true</span>; </span><br><span class="line">            cnt += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hit) &#123; <span class="comment">//找不到</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="built_in">set</span> * E; i &lt; (<span class="built_in">set</span> + <span class="number">1</span>) * E; i++) &#123; <span class="comment">//去到相应set所在</span></span><br><span class="line">            <span class="keyword">if</span> (!cache[i].valid) <span class="comment">//找到空的地方退出</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="built_in">set</span> + <span class="number">1</span>) * E) &#123; <span class="comment">// 到最后仍然没有找到空的地方，执行随机替换算法</span></span><br><span class="line">            srand(<span class="number">0</span>);</span><br><span class="line">            i = <span class="built_in">set</span> * E + rand() % E;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[i].valid = <span class="literal">true</span>;</span><br><span class="line">        cache[i].tag = addr &gt;&gt; <span class="number">13</span>;</span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">       <span class="keyword">uint32_t</span> block = (addr &gt;&gt; <span class="number">6</span>) &lt;&lt; <span class="number">6</span>; <span class="comment">// 取出block</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BURST_LEN; j++) &#123;</span><br><span class="line">            call_ddr3_read(block + j * BURST_LEN, cache[i].byte + j * BURST_LEN); </span><br><span class="line">         &#125;</span><br><span class="line">        cnt += <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">set</span> = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7f</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset = addr &amp; (CACHE_BLOCK - <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">bool</span> hit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">set</span> * E; i &lt; (<span class="built_in">set</span> + <span class="number">1</span>) * E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[i].tag == (addr &gt;&gt; <span class="number">13</span>) &amp;&amp; cache[i].valid) &#123;</span><br><span class="line">            hit = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hit) &#123; <span class="comment">// 写直通</span></span><br><span class="line">        <span class="built_in">memcpy</span>(cache[i].byte + offset, &amp;data, len);</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        i = cache_read(addr);</span><br><span class="line">         <span class="built_in">memcpy</span>(cache[i].byte + offset, &amp;data, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解了cache的原理就很好实现了。这里有一个变量cnt用来观察成功实现了cache后，运行用户程序所需要的时间。</p>
<center><b>nemu/src/memory/dram.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_ddr3_read</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">void</span> *data)</span></span>&#123;</span><br><span class="line">	ddr3_read(addr,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_ddr3_write</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">void</span> *data, <span class="keyword">uint8_t</span> *mask)</span></span>&#123;</span><br><span class="line">	ddr3_write(addr,data,mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数实际上就是调用ddr3里的函数，作为一个接口。</p>
<center><b>nemu/src/monitor/monitor.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">	<span class="comment">/* Initialize cache */</span></span><br><span class="line">	init_cache();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在restart中对cache进行一个初始化操作。</p>
<center><b>nemu/src/monitor/memory/memory.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">hwaddr_read</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> offset = addr &amp; (CACHE_BLOCK - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> block = cache_read(addr);</span><br><span class="line">	<span class="keyword">uint8_t</span> temp[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">	<span class="keyword">if</span> (offset + len &gt;= CACHE_BLOCK) &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> second_block = cache_read(addr + len);</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, cache[block].byte + offset, CACHE_BLOCK - offset);</span><br><span class="line">		<span class="built_in">memcpy</span>(temp + CACHE_BLOCK - offset, cache[second_block].byte, len - (CACHE_BLOCK - offset));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(temp, cache[block].byte + offset, len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> result = unalign_rw(temp + zero, <span class="number">4</span>) &amp; (~<span class="number">0u</span> &gt;&gt; ((<span class="number">4</span> - len) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">	<span class="comment">//printf(&quot;time: %ld\n&quot;, cnt);</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hwaddr_write</span><span class="params">(<span class="keyword">hwaddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> data)</span> </span>&#123;</span><br><span class="line">	cache_write(addr, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要在修改两个函数，就不是直接读写DRAM了，需要先调用cache，当cache缺失的时候才读写DRAM。</p>
<hr>
<h2 id="选做任务-1：实现二级-Cache"><a href="#选做任务-1：实现二级-Cache" class="headerlink" title="选做任务 1：实现二级 Cache"></a>选做任务 1：实现二级 Cache</h2><p>这里其实和实现L1的cache很类似，L2相比L2需要加上一个dirty位。当L1如果不命中，需要到L2里去找，最后当L2缺失的时候，才去DRAM里找。相关代码就不再贴出了。</p>
<hr>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>在16位的时代，所有寄存器都是16位，所以访存最大的范围也只是在2^16 = 64KB，所以这时候引进了一个伟大的概念，叫做分段。分段其实就是把内存分成一段一段，并且增加了一些16位的寄存器来协助寻址，这些寄存器称为段寄存器，里面存储着段基地址。段基地址* 16 + 偏移量 = 物理地址，利用段寄存器就可以访问到2^20 = 1MB的内存了。当程序需要执行的时候，就要确定程序相应的区域各自要放在哪里，这时候这四个段寄存器就会分别指向这些起始位置，这是约定俗成，现在也是如此。</p>
<ul>
<li>代码段寄存器CS：存放当前执行的程序的段地址。</li>
<li>数据段寄存器DS：存放当前执行的程序所用操作数的段地址。</li>
<li>堆栈段寄存器SS：存放当前执行的程序所用堆栈的段地址。</li>
<li>附加段寄存器ES：存放当前执行程序中一个辅助数据段的段地址。</li>
</ul>
<p>到了32位的时代，由于历史和兼容性原因，段寄存器必须保留，但是所有的寄存器都已经是32位了，一个段寄存器只有16位，是无法放下一个32位的基地址的。所以intel想了一个牛逼的办法，把一个段的各种属性放在一起，形成一个新的概念，叫做段描述符。这个段描述符是64位的，intel把所有的段描述符放在一个数组当中，称作全局描述符表GDT（Global  Descriptor Table），段寄存器则用来充当这个数组的索引，这时候段寄存器就被称作段选择符。除了全局描述符表，还有中断描述符表IDT（Interrupt Descriptor Table）以及局部描述符表LDT（Local Descriptor Table）。</p>
<center><b>段选择符结构</b></center>

<p><img src="https://www.cs.cmu.edu/~410/doc/segments/segsel.gif"></p>
<center><b>段描述符结构</b></center>

<p><img src="https://lh3.googleusercontent.com/proxy/1jwqePVVHC3nSWQnPTTbegSX4eYiZ8n60TH-Hy4vwuqzz5aXl4YlJh4XWEilQn_PJGab2-CTU8GV0H5oNFWObUXmZif6LPSyrfDTsxMATYBTYqGzkg"></p>
<p>这时候必须要有一个指向全局唯一的GDT的寄存器，intel把它称作GDTR。这个GDTR里存的必然是线性地址，因为分段机制就是把逻辑地址转为线性地址的过程，如果这个GDTR里存放的是逻辑地址，那也没有其他机制能把GDTR里的地址从逻辑地址转为线性地址了。</p>
<center><b>逻辑地址转线性地址的过程</b></center>

<p><img src="https://www.cs.umd.edu/~meesh/cmsc411/website/saltz/cs412/lect3-p2.gif"></p>
<p>所以寻址的过程就变成：</p>
<ol>
<li>首先要有通用寄存器的32位有效地址，也可以称作段内偏移。</li>
<li>根据段选择符中的TI决定在哪个描述符表中取值。</li>
<li>找到相应的描述符表后，利用描述符表寄存器里的值找到描述符表的首地址，并且加上段描述符中的索引 * 8 （段描述符占8字节）。</li>
<li>比较RPL和DPL和当前进程的CPL，这是x86的保护机制（必须满足DPL &gt;= RPL &amp;&amp; DPL &gt;=CPL）。</li>
<li>最后将段描述符中的32位地址和有效地址相加，得到32位线性地址。</li>
</ol>
<hr>
<h2 id="必做任务2：在-NEMU-中实现分段机制"><a href="#必做任务2：在-NEMU-中实现分段机制" class="headerlink" title="必做任务2：在 NEMU 中实现分段机制"></a>必做任务2：在 NEMU 中实现分段机制</h2><p>在寄存器结构体中添加段寄存器后，需要编写一个lgdt指令，这个指令是用来加载全局描述符表的。之后要完善未实现的一些指令，运行NEMU的时候会指示出来。mov指令中要设置cr0，进入分段机制。修改两个函数swaddr_read()和 swaddr_write()，使其实现分段机制的转换。在有使用到段寄存器的指令中设置对应的段寄存器，有些函数也要进行设置，例如instr_fetch()和read_ModR_M()，并且之前实现的有些打印操作也要设置相应的段寄存器。实现Opcode为8E的mov指令后需要设置段寄存器，在里面调用sreg_load()用来拼接属性。切到保护模式后取址操作要用到CS寄存器，要先在restart()函数中初始化CS寄存器。设置CS寄存器则要实现ljmp指令。下面会贴出一些比较关键的代码。</p>
<center><b>nemu/include/cpu/reg.h</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> R_ES, R_CS, R_SS, R_DS, R_FS, R_GS&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> selector;</span><br><span class="line">  <span class="keyword">uint16_t</span> attribute; <span class="comment">// type (is read or write or excutive)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> limit; <span class="comment">//length (base + limit = segment size)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> base; <span class="comment">// base address</span></span><br><span class="line">&#125; Segment_Reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GDTR</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> base;</span><br><span class="line">    <span class="keyword">uint16_t</span> limit;</span><br><span class="line">  &#125; gdtr;</span><br><span class="line"></span><br><span class="line">  CR0 cr0;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      Segment_Reg sreg[<span class="number">6</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      Segment_Reg es, cs, ss, ds, fs, gs;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  CR3 cr3;</span><br><span class="line">&#125; CPU_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">uint16_t</span> limit1;</span><br><span class="line">      <span class="keyword">uint16_t</span> base1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> part1;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">      <span class="keyword">uint32_t</span> base2:		<span class="number">8</span>; <span class="comment">//base address</span></span><br><span class="line">      <span class="keyword">uint32_t</span> a:			<span class="number">1</span>; <span class="comment">//is access</span></span><br><span class="line">      <span class="keyword">uint32_t</span> type:		<span class="number">3</span>; <span class="comment">//type</span></span><br><span class="line">      <span class="keyword">uint32_t</span> s:			<span class="number">1</span>; <span class="comment">//is data OR code segment</span></span><br><span class="line">      <span class="keyword">uint32_t</span> dpl:		<span class="number">2</span>; <span class="comment">//privilage</span></span><br><span class="line">      <span class="keyword">uint32_t</span> p:			<span class="number">1</span>;  <span class="comment">// is exist</span></span><br><span class="line">      <span class="keyword">uint32_t</span> limit2:	<span class="number">4</span>;  <span class="comment">//limit (segment length - 1)</span></span><br><span class="line">      <span class="keyword">uint32_t</span> avl:		<span class="number">1</span>; <span class="comment">//user</span></span><br><span class="line">      <span class="keyword">uint32_t</span> :			<span class="number">1</span>; <span class="comment">//32bit</span></span><br><span class="line">      <span class="keyword">uint32_t</span> x:			<span class="number">1</span>; <span class="comment">//16bit</span></span><br><span class="line">      <span class="keyword">uint32_t</span> g:			<span class="number">1</span>; <span class="comment">// page unit or byte unit (0 == 1 byte, 1 == 4kb)</span></span><br><span class="line">      <span class="keyword">uint32_t</span> base3:		<span class="number">8</span>; <span class="comment">//base address</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> part2;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; Sreg_Descriptor;</span><br><span class="line"></span><br><span class="line">Sreg_Descriptor *sreg_desc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sreg_load</span><span class="params">(<span class="keyword">uint8_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">uint8_t</span> current_sreg;</span><br></pre></td></tr></table></figure>

<p>Sreg_Descriptor则结构体是段描述符。Segment_Reg是参照着Sreg_Descriptor定义的结构体。sreg_load()这个函数要自己实现。这里我声明了一个变量current_sreg用来判断当前要使用哪个段寄存器，也可以依照实验指导书中的指示修改MEM_W() 和 MEM_R()这两个宏。</p>
<center><b>nemu/src/cpu/reg.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sreg_load</span><span class="params">(<span class="keyword">uint8_t</span> sreg_num)</span> </span>&#123;</span><br><span class="line">  Assert(cpu.cr0.protect_enable, <span class="string">&quot;Not In Protect Mode!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint16_t</span> idx = cpu.sreg[sreg_num].selector &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  Assert((idx &lt;&lt; <span class="number">3</span>) &lt;= cpu.gdtr.limit, <span class="string">&quot;Segement Selector Is Out Of The Limit!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lnaddr_t</span> chart_addr = cpu.gdtr.base + (idx &lt;&lt; <span class="number">3</span>);</span><br><span class="line">  sreg_desc -&gt; part1 = lnaddr_read(chart_addr, <span class="number">4</span>);</span><br><span class="line">  sreg_desc -&gt; part2 = lnaddr_read(chart_addr + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  Assert(sreg_desc -&gt; p == <span class="number">1</span>, <span class="string">&quot;Segement Not Exist!&quot;</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> bases = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bases += ((<span class="keyword">uint32_t</span>)sreg_desc -&gt; base1);</span><br><span class="line"></span><br><span class="line">  bases += ((<span class="keyword">uint32_t</span>)sreg_desc -&gt; base2) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  bases += ((<span class="keyword">uint32_t</span>)sreg_desc -&gt; base3) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  cpu.sreg[sreg_num].base = bases;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> limits = <span class="number">0</span>;</span><br><span class="line">  limits += ((<span class="keyword">uint32_t</span>)sreg_desc -&gt; limit1);</span><br><span class="line">  limits += ((<span class="keyword">uint32_t</span>)sreg_desc -&gt; limit2) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  limits += ((<span class="keyword">uint32_t</span>)<span class="number">0xfff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  cpu.sreg[sreg_num].limit = limits;</span><br><span class="line">  <span class="keyword">if</span> (sreg_desc -&gt; g == <span class="number">1</span>) &#123;</span><br><span class="line">      cpu.sreg[sreg_num].limit &lt;&lt;= <span class="number">12</span>;<span class="comment">//G = 0, unit = 1B;G = 1, unit = 4KB</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是来拼接一些属性的，在Opcode为8E的mov指令中调用。</p>
<center><b>nemu/src/memory/memory.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">lnaddr_t</span> <span class="title">seg_translate</span><span class="params">(<span class="keyword">swaddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint8_t</span> sreg_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cpu.cr0.protect_enable == <span class="number">0</span>) <span class="keyword">return</span> addr;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cpu.sreg[sreg_id].base + addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">swaddr_read</span><span class="params">(<span class="keyword">swaddr_t</span> addr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  assert(len == <span class="number">1</span> || len == <span class="number">2</span> || len == <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">lnaddr_t</span> lnaddr = seg_translate(addr, len, current_sreg);</span><br><span class="line">  <span class="keyword">return</span> lnaddr_read(lnaddr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swaddr_write</span><span class="params">(<span class="keyword">swaddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> data)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  assert(len == <span class="number">1</span> || len == <span class="number">2</span> || len == <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">lnaddr_t</span> lnaddr = seg_translate(addr, len, current_sreg);</span><br><span class="line">  lnaddr_write(lnaddr, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>seg_translate()中判断是否在保护模式，如果是的话，返回描述符表基地址+索引+有效地址。然后对swaddr_read()和swaddr_write()这两个函数进行修改，实现分段地址的转换。</p>
<center><b>nemu/src/monitor/monitor.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_CS</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cpu.cs.base = <span class="number">0</span>;</span><br><span class="line">  	cpu.cs.limit = <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_cr0</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cpu.cr0.protect_enable = <span class="number">0</span>; <span class="comment">//real mode turn to protect mode</span></span><br><span class="line">	<span class="comment">//cpu.cr0.paging = 0; //page mode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> 	<span class="comment">/* Initialize CR0. */</span></span><br><span class="line">	init_cr0();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize CS. */</span></span><br><span class="line">	init_CS();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据实验指导书中的指示初始化CS寄存器和cr0，分段机制也就实现了。</p>
<hr>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>由于分段机制中段的大小不固定，在段的换入换出中会产生很多内存碎片，从而导致浪费很多内存空间，所以又迎来了分页机制。页的大小是固定且是系统决定的，并且产生的碎片很少，可以说分页模式是为了解决分段模式的缺点而产生的。</p>
<center><b>线性地址转物理地址的过程</b></center>

<p><img src="https://www.cs.uaf.edu/2007/fall/cs301/lecture/11_30_cache.png"></p>
<p>分页机制采用两级页表的形式，并且也有一个寄存器CR3存储着页目录基地址。由分段机制得到的线性地址可以分成三个部分，分别为页目录表索引、页表索引、页内偏移量。Linux中的页目录中的页目录项一共有1K个，而每个页目录项又拥有1K个页项，每个页项大小为4KB。</p>
<center><b>页目录项和页表项的格式</b></center>

<p><img src="https://i.stack.imgur.com/PolxM.png"></p>
<p>所以分页机制的寻址过程就是：</p>
<ol>
<li>由页目录基地址 + 页目录表索引 * 4（每个表项占4个字节）得到页目录表中对应的页目录项。</li>
<li>页目录项 + 页表索引 * 4得到第二级页表中的页项。</li>
<li>页项 + 页内偏移量得到相应的物理地址。</li>
</ol>
<hr>
<h2 id="必做任务-3：在-NEMU-中实现分页机制"><a href="#必做任务-3：在-NEMU-中实现分页机制" class="headerlink" title="必做任务 3：在 NEMU 中实现分页机制"></a>必做任务 3：在 NEMU 中实现分页机制</h2><p>首先要添加CR3寄存器，并且也要初始化CR0寄存器中的paging。修改 lnaddr_read()和 lnaddr_write()函数，实现分页机制。之后根据实验指导书中指示的部分把需要修改的部分修改，最后要在<strong>nemu/kerne/src/elf/elf.c</strong>中调用内存分配的接口函数mm_malloc()。</p>
<center><b>nemu/src/memory/memory.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">hwaddr_t</span> <span class="title">page_translate</span><span class="params">(<span class="keyword">lnaddr_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cpu.cr0.protect_enable == <span class="number">1</span> &amp;&amp; cpu.cr0.paging == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> dir = addr &gt;&gt; <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> page = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3ff</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset = addr &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = read_tlb(addr);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (tlb[i].page_num &lt;&lt; <span class="number">12</span>) + offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> dir_start = cpu.cr3.page_directory_base;</span><br><span class="line">    <span class="keyword">uint32_t</span> dir_position = (dir_start &lt;&lt; <span class="number">12</span>) + (dir &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    Page_Descriptor first_content;</span><br><span class="line">    first_content.val = hwaddr_read(dir_position, <span class="number">4</span>);</span><br><span class="line">    Assert(first_content.p, <span class="string">&quot;pagevalue = %x eip = %x&quot;</span>, first_content.val,cpu.eip);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_start = first_content.addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> page_pos = (page_start &lt;&lt; <span class="number">12</span>) + (page &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    Page_Descriptor second_content;</span><br><span class="line">    second_content.val =  hwaddr_read(page_pos, <span class="number">4</span>);</span><br><span class="line">    Assert(second_content.p == <span class="number">1</span>, <span class="string">&quot;Page Cannot Be Used!, %x&quot;</span>, cpu.eip);</span><br><span class="line">    <span class="keyword">uint32_t</span> addr_start = second_content.addr;</span><br><span class="line">    <span class="keyword">hwaddr_t</span> hwaddr = (addr_start &lt;&lt; <span class="number">12</span>) + offset;</span><br><span class="line">    write_tlb(addr, hwaddr);</span><br><span class="line">    <span class="keyword">return</span> hwaddr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">lnaddr_read</span><span class="params">(<span class="keyword">lnaddr_t</span> addr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  assert(len == <span class="number">1</span> || len == <span class="number">2</span> || len == <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> now_offset = addr &amp; <span class="number">0xfff</span>;</span><br><span class="line">  <span class="keyword">if</span> (now_offset + len - <span class="number">1</span> &gt; <span class="number">0xfff</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> len1 = <span class="number">0xfff</span> - now_offset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len2 = len - len1;</span><br><span class="line">    <span class="keyword">uint32_t</span> addr_len1 = lnaddr_read(addr, len1);</span><br><span class="line">    <span class="keyword">uint32_t</span> addr_len2 = lnaddr_read(addr + len1, len2);</span><br><span class="line">    <span class="keyword">uint32_t</span> value = (addr_len2 &lt;&lt; (len1 &lt;&lt; <span class="number">3</span>)) | addr_len1;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">hwaddr_t</span> hwaddr = page_translate(addr);</span><br><span class="line">    <span class="keyword">return</span> hwaddr_read(hwaddr, len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lnaddr_write</span><span class="params">(<span class="keyword">lnaddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> data)</span> </span>&#123;</span><br><span class="line">  assert(len == <span class="number">1</span> || len == <span class="number">2</span> || len == <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> now_offset = addr &amp; <span class="number">0xfff</span>;</span><br><span class="line">  <span class="keyword">if</span> (now_offset + len - <span class="number">1</span> &gt; <span class="number">0xfff</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> len1 = <span class="number">0xfff</span> - now_offset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len2 = len - len1;</span><br><span class="line">    lnaddr_write(addr, len1, data &amp; ((<span class="number">1</span> &lt;&lt; (len1 &lt;&lt; <span class="number">3</span>)) - <span class="number">1</span>));</span><br><span class="line">    lnaddr_write(addr + len1, len2, data &gt;&gt; (len1 &lt;&lt; <span class="number">3</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">hwaddr_t</span> hwaddr = page_translate(addr);</span><br><span class="line">    hwaddr_write(hwaddr, len, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>page_translate()要判断是否已经开启了分段和分页的机制，之后就可以实现分页机制的转换。tlb是类似cache的一种，调用这两个函数read_tlb()和write_tlb()前需要实现先tlb，之后会说到。</p>
<center><b>kernel/src/elf/elf.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...	</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++) &#123;</span><br><span class="line">		<span class="comment">/* Scan the program header table, load each segment into memory */</span></span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">			</span><br><span class="line">			ph-&gt;p_vaddr = mm_malloc(ph-&gt;p_vaddr,ph-&gt;p_memsz);</span><br><span class="line">			<span class="keyword">uint32_t</span> pa = ph-&gt;p_vaddr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> read the content of the segment from the ELF file </span></span><br><span class="line"><span class="comment">			 * to the memory region [VirtAddr, VirtAddr + FileSiz)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ramdisk_read((<span class="keyword">void</span> *)pa,ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line">			 </span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> zero the memory region </span></span><br><span class="line"><span class="comment">			 * [VirtAddr + FileSiz, VirtAddr + MemSiz)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">memset</span>((<span class="keyword">void</span>*)pa+ph-&gt;p_filesz,<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);</span><br><span class="line">			</span><br><span class="line">			ph ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>调用内存分配的mm_malloc()函数，至此开启了分页机制。</p>
<hr>
<h2 id="选做任务-2：简易调试器"><a href="#选做任务-2：简易调试器" class="headerlink" title="选做任务 2：简易调试器"></a>选做任务 2：简易调试器</h2><p>只是需要在<strong>nemu/src/memory/memory.c</strong>增加一个和page_translate类似的函数，实现方式差不多是相同的，之后在nemu/src/monitor/debug/ui.c**添加相应的指令即可，代码就不贴出来了。</p>
<hr>
<h2 id="选做任务-3：为用户进程创建-video-memory-映射"><a href="#选做任务-3：为用户进程创建-video-memory-映射" class="headerlink" title="选做任务 3：为用户进程创建 video memory 映射"></a>选做任务 3：为用户进程创建 video memory 映射</h2><p>没做。</p>
<hr>
<h2 id="必做任务-4：实现-TLB"><a href="#必做任务-4：实现-TLB" class="headerlink" title="必做任务 4：实现 TLB"></a>必做任务 4：实现 TLB</h2><p>和之前实现高速缓存的概念是差不多的，利用TLB和局部性原理存储一些地址。如果tlb命中，已经转换过的地址不再需要经过分段和分页机制进行转换，从而改善转换速度。</p>
<center><b>kernel/include/memory/tlb.h</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TLB_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TLB_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TLB_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid_value;</span><br><span class="line">    <span class="keyword">uint32_t</span> tag, page_num;</span><br><span class="line">&#125; TLB;</span><br><span class="line"></span><br><span class="line">TLB tlb[TLB_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_tlb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_tlb</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_tlb</span><span class="params">(<span class="keyword">uint32_t</span> lnaddr, <span class="keyword">uint32_t</span> hwaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>定义tlb的结构。</p>
<center><b>kernel/src/memory/tlb.c</b></center>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memory/tlb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;burst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_tlb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TLB_SIZE; i++) &#123;</span><br><span class="line">    tlb[i].valid_value = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_tlb</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dir = addr &gt;&gt; <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TLB_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tlb[i].tag == dir &amp;&amp; tlb[i].valid_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_tlb</span><span class="params">(<span class="keyword">uint32_t</span> lnaddr, <span class="keyword">uint32_t</span> <span class="keyword">hwaddr_t</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dir = lnaddr &gt;&gt; <span class="number">12</span>, page_num = <span class="keyword">hwaddr_t</span> &gt;&gt; <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TLB_SIZE; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tlb[i].valid_value) &#123;</span><br><span class="line">      tlb[i].valid_value = <span class="literal">true</span>;</span><br><span class="line">      tlb[i].tag = dir;</span><br><span class="line">      tlb[i].page_num = page_num;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  srand(time(<span class="number">0</span>));</span><br><span class="line">  i = rand() % TLB_SIZE;</span><br><span class="line">  tlb[i].valid_value = <span class="literal">true</span>;</span><br><span class="line">  tlb[i].tag = dir;</span><br><span class="line">  tlb[i].page_num = page_num;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现tlb后，最后在<strong>nemu/src/memory/memory.c</strong>中的page_translate()调用即可。</p>
<hr>
<h2 id="任务自查表"><a href="#任务自查表" class="headerlink" title="任务自查表"></a>任务自查表</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">是否已完成</th>
</tr>
</thead>
<tbody><tr>
<td align="center">必做任务1</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">必做任务2</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">必做任务3</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">必做任务4</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">选做任务1</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">选做任务2</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">选做任务3</td>
<td align="center">否</td>
</tr>
</tbody></table>
<hr>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>PA3思考题有些难，不大确定自己的是不是对的，就不贴出来了。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>PA3也完成了，剩余的部分有缘再做。</p>
<br>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>aa10n
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://aa10n.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA3/" title="计算机系统基础综合实践 NEMU PA3">https://aa10n.github.io/计算机系统基础/NEMUPA3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/NEMU/" rel="tag"><i class="fa fa-tag"></i> NEMU</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NEMUPA2/" rel="prev" title="计算机系统基础综合实践 NEMU PA2">
                  <i class="fa fa-chevron-left"></i> 计算机系统基础综合实践 NEMU PA2
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-plug"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aa10n</span>
</div>


    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
